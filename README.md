# iq_resample_tool

### Overview

`iq_resample_tool` is a command-line utility for resampling and manipulating In-phase/Quadrature (I/Q) data streams. It reads I/Q data from files or Software Defined Radio (SDR) devices and outputs it to various destinations and formats.

The tool's development was initially driven by requirements for **NRSC-5 (HD Radio) processing**, specifically for preparing I/Q WAV captures for external decoders such as `nrsc5`. This origin is reflected in its robust WAV file metadata handling and precise frequency shifting capabilities, which are relevant for isolating and manipulating specific digital sidebands within recorded signals.

`iq_resample_tool` provides functionality to adjust I/Q sample rates, formats, and frequencies for subsequent processing or analysis.

---

## ⚠️ *Important Note: Heavy AI-Assisted Development* ⚠️

**The development of this project was largely assisted by a large language model (AI).** The initial code structure, core logic, and build systems were generated by AI and have since been guided, reviewed, and tested by a human developer.

While the tool is functional and has been refined, its unique development process means it has not undergone the same long-term, iterative evolution as a traditional open-source project. It should still be considered experimental.

**Please be aware of the following:**
* **Potential for Bugs:** Issues are still likely present. Subtle bugs, logical errors, or memory management issues may exist.
* **Edge Cases:** The tool may not gracefully handle all possible inputs, file formats, or command-line argument combinations.
* **Security:** No formal security audit has been performed. Use caution with untrusted input files.

## Please use this tool with this context in mind and review the code if you intend to use it for any critical purpose.

---

### Key Features 

* **Multi-Threaded Processing:** Employs a reader -> processor -> writer pipeline for data throughput on multi-core systems.

* **Input Sources:**
* * **SDRplay:** Supports SDRplay RSP devices.
* * **HackRF:** Supports HackRF One devices.
* * **WAV Files:** Reads 8-bit and 16-bit complex (I/Q) WAV files.

* **Metadata Handling (WAV Files):**
* * **Intelligent Frequency Adjustment:** For WAV files, when using `--wav-center-target-frequency`, the tool calculates the required frequency shift. This is done by reading embedded frequency metadata, a feature relevant for aligning NRSC-5 (HD Radio) captures.
* * **Broad Metadata Support:** Parses metadata from various sources within WAV files, including:
* * * `auxi` chunks generated by **SDR Console, SDRconnect,** and **SDRuno.**
* * * Filenames generated by **SDR#** (e.g., `..._20240520_181030Z_97300000Hz_...`).

* **Output Options:**
* * **Container Formats:** Outputs as headerless `raw` I/Q, standard `wav`, or `wav-rf64` for large files.
* * **Sample Formats:** Supports `cs16` (16-bit signed), `cs8` (8-bit signed), and `cu8` (8-bit unsigned) complex samples.
* * **Presets:** Allows loading predefined output configurations from a file.

* **Processing Control:**
* * **Resampling:** Uses `liquid-dsp` for polyphase resampling to a user-defined rate.
* * **Frequency Shifting:** Applies frequency shifts using an NCO. The `--wav-shift-after-resample` flag can apply shifts after resampling, which may be useful for narrow I/Q recordings.
* * **8-Bit Processing:** The `--no-8-to-16` flag enables a native 8-bit processing path for 8-bit to 8-bit workflows.

* **System Compatibility:**
* * Handles graceful shutdown on `Ctrl+C`.
* * Uses CMake for cross-platform building (Linux, Windows, other POSIX systems).

### Dependencies

To build this project, you will need:
* A C99 compliant C compiler (GCC, Clang, or MSVC).
* **CMake** (version 3.10 or higher).
* **libsndfile** (development headers and library).
* **liquid-dsp** (development headers and library).
* **libexpat** (development headers and library).
* **pthreads** (On Linux/macOS this is standard; on Windows, MinGW provides a version).
* **(Optional) SDRplay API Library:** To build with SDRplay support, you must first download and install the official API from the [SDRplay website](https://www.sdrplay.com/downloads/).
* **(Optional) HackRF Library (libhackrf) and libusb:** To build with HackRF support, you must install the host libraries. On Linux, this is typically `libhackrf-dev` and `libusb-1.0-0-dev`.

### Building the Project

#### On Linux

1.  **Install Dependencies:**
```bash
# On Debian/Ubuntu
sudo apt-get update
sudo apt-get install build-essential cmake libsndfile1-dev libliquid-dev libexpat1-dev libhackrf-dev libusb-1.0-0-dev

# On Fedora/CentOS
sudo dnf install cmake gcc-c++ libsndfile-devel liquid-dsp-devel expat-devel hackrf-devel libusbx-devel
```

2.  **Configure and Build:**
```bash
git clone https://github.com/pclov3r/iq_resample_tool.git
cd iq_resample_tool
mkdir build
cd build

# To build with default options (no SDRs):
cmake ..

# To build WITH SDRplay and/or HackRF support:
cmake -DWITH_SDRPLAY=ON -DWITH_HACKRF=ON ..

make
```
The executable `iq_resample_tool` will be in the `build` directory.

#### On Windows

Building `iq_resample_tool` for Windows is typically performed via cross-compilation (e.g., using a MinGW-w64 toolchain on a Linux host) or within a Windows-based environment like MSYS2.

For optimal performance, different binary variants are compiled with specific CPU instruction set extensions. These variants are linked against corresponding `liquid-dsp` libraries that are also compiled with these extensions. A dedicated build script is used to manage this process.

* **AVX Variant:** Requires a CPU supporting AVX instructions (e.g., Intel Sandy Bridge/Ivy Bridge or newer). This variant of the tool is compiled with `x86-64-v2` architecture flags and links against an AVX-optimized `liquid-dsp` library. `liquid-dsp` will utilize AVX instructions at runtime if supported by the CPU.
* **AVX2 Variant:** Requires a CPU supporting AVX2 instructions (e.g., Intel Haswell or newer). This variant is compiled with `x86-64-v3` architecture flags and links against an AVX2-optimized `liquid-dsp` library.

Using a variant compiled for a CPU instruction set not supported by your processor will result in the program **crashing**.

**Important:**
* All the required library files (`dll`s) must be in the same directory as the executable.
* To use an SDR, you must first install its official Windows drivers and/or API from the manufacturer's website (e.g., SDRplay API, Zadig for HackRF).

#### Windows Build Script

A dedicated build script (e.g., `support/win-cross-compile` in the repository root) is used to simplify the cross-compilation process for Windows. This script handles setting up the correct compiler, linking the appropriate `liquid-dsp` variant, and configuring CPU architecture flags.

**Important Note on Paths and Naming:**
The `support/win-cross-compile` script contains **hardcoded paths** to the dependency libraries. It also assumes a specific naming scheme and directory structure for the pre-compiled `liquid-dsp` library variants (e.g., `build-win64-avx/libliquid.dll.a`, `build-win64-avx2/libliquid.dll.a`). You will need to **edit this script** to adjust these paths and verify the assumed naming scheme matches your compiled Windows dependencies on your build system. Refer to the comments within the script for guidance.

### Usage

Run `iq_resample_tool --help` for a full list of command-line options and their descriptions.

```bash
./iq_resample_tool --help
```

#### Command-Line Options

```text
Usage: iq_resample_tool -i {wav <file_path> | sdrplay | hackrf} {--file <path> | --stdout} [options]

Description:
  Resamples an I/Q file or a stream from an SDR device to a specified format and sample rate.

Required Input:
  -i, --input <type>          Specifies the input type. Must be one of:
                                wav:      Input from a WAV file specified by <file_path>.
                                sdrplay:  Input from a SDRplay device.
                                hackrf:   Input from a HackRF device.

Output Destination (Required, choose one):
  -f, --file <file>           Output to a file.
  -o, --stdout                Output binary data for piping to another program.

Output Options:
  --output-container <type>   Specifies the output file container format.
                                Defaults to 'wav-rf64' for file output, 'raw' for stdout.
                                raw:      Headerless, raw I/Q sample data.
                                wav:      Standard WAV format (max 4GB, limited sample rates).
                                wav-rf64: RF64/BW64 format for large files and high sample rates.

  --output-sample-format <format> Sample format for output data. (Defaults to cs16 for file output).
                                cu8:   Unsigned 8-bit complex (WAV/RF64 output is unsigned 0-255, center 128).
                                cs8:   Signed 8-bit complex (Only for 'raw' output. WAV/RF64 does NOT support signed 8-bit).
                                cs16:  Signed 16-bit complex (Recommended for WAV/RF64 I/Q output).

SDR Options (Only valid when using an SDR input):
  --rf-freq <hz>              (Required) Tuner center frequency in Hz (e.g., 97.3e6).
  --bias-t                    (Optional) Enable Bias-T power.

SDRplay-Specific Options (Only valid with '--input sdrplay'):
  --sdrplay-sample-rate <hz>  Set sample rate in Hz. (Optional, Default: 2e6). Valid range: 2e6 to 10e6.
  --sdrplay-bandwidth <hz>    Set analog bandwidth in Hz. (Optional, Default: 1.536e6). Valid values: 200e3, 300e3, 600e3, 1.536e6, 5e6, 6e6, 7e6, 8e6.
  --sdrplay-device-idx <IDX>  Select specific SDRplay device by index (0-indexed). (Default: 0).
  --sdrplay-gain-level <LEVEL> Set manual gain level (0=min gain). Disables AGC. Max level varies by device/freq (e.g., RSP1A: 0-9, RSPdx @100MHz: 0-27).
  --sdrplay-antenna <PORT>    Select antenna port (device-specific). RSPdx/R2: A, B, C | RSP2: A, B, HIZ | RSPduo: A, HIZ (Not applicable for RSP1, RSP1A, RSP1B).
  --sdrplay-hdr-mode          (Optional) Enable HDR mode on RSPdx/RSPdxR2.
  --sdrplay-hdr-bw <BW_MHZ>   Set bandwidth for HDR mode. Requires --sdrplay-hdr-mode. (Default: 1.7). Valid values: 0.2, 0.5, 1.2, 1.7.

HackRF-Specific Options (Only valid with '--input hackrf'):
  --hackrf-sample-rate <hz>   Set sample rate in Hz. (Optional, Default: 8e6). Valid range is 2-20 Msps (e.g., 2e6, 10e6, 20e6). Automatically selects a suitable baseband filter.
  --hackrf-lna-gain <db>      Set LNA (IF) gain in dB. (Optional, Default: 16). Valid values: 0-40 in 8 dB steps (e.g., 0, 8, 16, 24, 32, 40).
  --hackrf-vga-gain <db>      Set VGA (Baseband) gain in dB. (Optional, Default: 0). Valid values: 0-62 in 2 dB steps (e.g., 0, 2, 4, ... 62).
  --hackrf-amp-enable         Enable the front-end RF amplifier (+14 dB).

WAV Input Specific Options (Only valid with '--input wav'):
  --wav-center-target-frequency <hz> Shift signal to a new target center frequency (e.g., 97.3e6). (Recommended for WAV captures with frequency metadata).
  --wav-shift-frequency <hz>  Apply a direct frequency shift in Hz. (Use if WAV input lacks metadata or for manual correction).
  --wav-shift-after-resample  Apply frequency shift AFTER resampling (default is before). (A workaround for narrow I/Q WAV recordings where only a single HD sideband is present).

Processing Options:
  --output-rate <hz>          Output sample rate in Hz. (Required if no preset is used). (Cannot be used with --preset or --no-resample).
  --scale <value>             Scaling factor for input samples (Default: 0.02 for 8-bit, 0.5 for 16-bit).
  --no-resample               Disable the resampler (passthrough mode). Output sample rate will be the same as the input rate.
  --no-8-to-16                Use a native 8-bit processing path, skipping internal scaling. (Only valid for 8-bit input and an 8-bit output mode). (May provide a minor performance improvement).
  --preset <name>             Use a preset for a common target. (Cannot be used with --no-resample).
                                Loaded presets:
                                cu8-nrsc5:       Sets sample type to cu8, rate to 1488375.0 Hz.
                                cs16-fm-nrsc5:   Sets sample type to cs16, rate to 744187.5 Hz.
                                cs16-am-nrsc5:   Sets sample type to cs16, rate to 46511.71875 Hz.
```

#### Examples

**Example 1: Basic File Resampling**
Resample a WAV file to a 16-bit RF64 (large WAV) file with a custom output rate.
```bash
iq_resample_tool -i my_capture.wav --file my_capture_resampled.wav --output-container wav-rf64 --output-sample-format cs16 --output-rate 240000
```

**Example 2: Piping to a Decoder with a Preset (WAV Input)**
Use the `cu8-nrsc5` preset to resample and automatically correct the frequency, then pipe it to `nrsc5`. (Assumes the WAV has frequency metadata).
```bash
iq_resample_tool -i sdrsharp_capture.wav --wav-center-target-frequency 97.3e6 --preset cu8-nrsc5 --stdout | nrsc5 -r - 0
```

**Example 3: Streaming from a HackRF Device with Preset**
Tune a HackRF to 98.5 MHz, set LNA and VGA gain, and pipe the output to another program using the `cu8-nrsc5` preset.
```bash
iq_resample_tool -i hackrf --rf-freq 98.5e6 --hackrf-lna-gain 24 --hackrf-vga-gain 16 --preset cu8-nrsc5 --stdout | other_tool
```

**Example 4: Streaming from an SDRplay Device with Preset**
Tune an SDRplay RSPdx to 102.5 MHz, set a manual gain level and select a specific antenna port before piping to a decoder using the `cu8-nrsc5` preset.
```bash
iq_resample_tool -i sdrplay --rf-freq 102.5e6 --sdrplay-gain-level 20 --sdrplay-antenna B --preset cu8-nrsc5 --stdout | nrsc5 -r - 0
```

**Example 5: Manual Frequency Correction (WAV Input)**
Apply a direct -400 kHz frequency shift to a file that lacks metadata, using the `cu8-nrsc5` preset.
```bash
iq_resample_tool -i capture_no_meta.wav --wav-shift-frequency -400e3 --preset cu8-nrsc5 --stdout | nrsc5 -r - 0
```

**Example 6: Workaround for Narrow Sideband Recordings (WAV Input)**
Use the `--wav-shift-after-resample` flag to process a narrow HD I/Q recording where the desired signal is off-center after resampling, using the `cu8-nrsc5` preset.
```bash
iq_resample_tool -i narrow_capture.wav --wav-center-target-frequency 97.3e6 --preset cu8-nrsc5 --wav-shift-after-resample --stdout | nrsc5 -r - 0
```

#### Windows Binaries

Precompiled 64-bit Windows executables may be provided with each release. These binaries are typically built using MinGW-w64 and are dynamically linked.

For optimal performance, different binary variants are compiled with specific CPU instruction set extensions. These variants are linked against corresponding `liquid-dsp` libraries that are also compiled with these extensions. A dedicated build script is used to manage this process.

* **AVX Variant:** Requires a CPU supporting AVX instructions (e.g., Intel Sandy Bridge/Ivy Bridge or newer). This variant of the tool is compiled with `x86-64-v2` architecture flags and links against an AVX-optimized `liquid-dsp` library. `liquid-dsp` will utilize AVX instructions at runtime if supported by the CPU.
* **AVX2 Variant:** Requires a CPU supporting AVX2 instructions (e.g., Intel Haswell or newer). This variant is compiled with `x86-64-v3` architecture flags and links against an AVX2-optimized `liquid-dsp` library.

Using a variant compiled for a CPU instruction set not supported by your processor will result in the program **crashing**.

**Important:**
* All the required library files (`dll`s) must be in the same directory as the executable.
* To use an SDR, you must first install its official Windows drivers and/or API from the manufacturer's website (e.g., SDRplay API, Zadig for HackRF).

### Configuration (Presets)

`iq_resample_tool` supports loading presets from a configuration file named `iq_resample_tool_presets.conf`. This file allows you to define common output configurations (target sample rate, sample format, output container type) that can be easily applied using the `--preset <name>` command-line option.

#### Presets File Search Paths

The tool searches for `iq_resample_tool_presets.conf` in the following locations, in order:

* **Windows:**
* * The directory where `iq_resample_tool.exe` is located.
* * `%APPDATA%\iq_resample_tool\` (e.g., `C:\Users\<YourUsername>\AppData\Roaming\iq_resample_tool\`)
* * `%PROGRAMDATA%\iq_resample_tool\` (e.g., `C:\ProgramData\iq_resample_tool\`)
* **Linux/macOS:**
* * The current working directory (`.`).
* * `$XDG_CONFIG_HOME/iq_resample_tool/` (or `~/.config/iq_resample_tool/` if `XDG_CONFIG_HOME` is not set).
* * `~/.iq_resample_tool/` (an older dotfile convention).
* * `/etc/iq_resample_tool/`
* * `/usr/local/etc/iq_resample_tool/`
* * `/usr/share/iq_resample_tool/`

#### Resolving Presets File Conflicts

If `iq_resample_tool_presets.conf` is found in **multiple** of the above locations, the tool will log a **warning** message listing all conflicting paths and **will not load any presets**. This is to prevent ambiguous behavior.

**To resolve a conflict:** You must manually delete all but one instance of the `iq_resample_tool_presets.conf` file from the conflicting locations. It is generally recommended to keep the one in your user-specific configuration directory (`%APPDATA%` or `~/.config/`) for personal overrides, or the system-wide installed one (`/usr/local/etc/iq_resample_tool/`).

### Known Issues and Limitations

* **Experimental:** As stated above, the code is not as extensively tested as a mature project and may contain bugs.
* **32-Bit Builds:** The build scripts are currently configured for 64-bit systems only.
* **Repeated Runs from Build Directory:** If running the executable directly from the build directory repeatedly without closing your terminal or IDE, you may encounter unexpected behavior or errors on subsequent runs. This is due to how the underlying argument parsing library (`getopt_long`) manages its internal state. For a clean run, it is recommended to restart your terminal session.

### TO DO

* **Raw File Input:** Add support for reading headerless I/Q data from generic binary files.
* **Airspy (Mini, R2, HF+, Discovery) support** (Hardware needed for development)
* **BladeRF Support**
* **Clean up code and comments:** Review and refine existing code and comments for clarity and consistency

### Contributing

Contributions are highly welcome! If you find a bug, a logical error, or an area for improvement, please feel free to:
* Open an issue to describe the problem.
* Submit a pull request with a fix.
